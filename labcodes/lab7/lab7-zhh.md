# Rerport: LAB7

计13，张宏辉，2011011237
 
## 练习0：填写已有实验
 - 已完成

## 练习1: 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题（不需要编码）

 - 请在实验报告中给出内核级信号量的设计描述，并说其大致执行流流程。
   - ucore中的内核级信号量在sem.h中给出了定义
   ```
   typedef struct {
      int value;
      wait_queue_t wait_queue;
   } semaphore_t;
   ```
    - 其中value是信号量，表示剩余资源数；wait_queue是对应的等待队列。

  - 阐述大致执行流程
    - 调用sem_init对信号量进行初始化
    - 线程请求资源时，调用down函数。这里的down函数其实对应P操作，如果value大于0则说明有资源，减一返回；否则信号量不足，将该线程加入请求队列
    - 线程释放资源时，调用up函数。这里的up函数其实对应V操作，如果等待队列为空则将value加一，否则唤醒等待队列中队头的操作

 - 请在实验报告中给出给用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同。
  - 用户态无法直接调用内核级函数，需要创建新的系统调用来实现。可以创建例如sys_init、sys_down、sys_up等系统调用，在中断处理历程中对应相应的内核级操作。
  - 与为内核级提供信号量机制相比
    - 相同之处：信号量结构本身也没有变化，初始化、P操作、V操作的具体实现都一样
    - 不同之处：不能直接在用户态实现信号量操作，必须通过中断等方式跳转到内核态统一接口进行操作和管理。
 
## 练习2: 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题（需要编码）

 - 简要说明你的设计实现过程
  - 需要就餐时，将状态设为HUNGRY，并查看左右两边的人是否在就餐。如果不在就餐则占用两边的叉子，否则等待。
  - 开始思考时，将状态设为THINKING，并查看左右两边的人是否处于等待中的饥饿，如果有则唤醒，否则直接释放。
  - 代码按照注释中的提示实现即可。

 - 请在实验报告中给出内核级条件变量的设计描述，并说其大致执行流流程。
  - ucore中的内核级条件变量定义如下
  ```
  typedef struct condvar{
    semaphore_t sem;
    int count;
    monitor_t * owner; // the owner(monitor) of this condvar
  } condvar_t;
  ```
    - 其中sem为信号量及相应等待队列，count为在该条件变量上等待的进程数，owner位该条件变量的管程

  - 阐述大致执行流程
    - 用餐时先申请mutex进入管程，将状态设为HUNGRY，查看相邻人的状态，若都不在就餐则占用两边刀叉，否则进入等待状态，释放mutex退出管程。
    - 思考时先申请mutex进入管程，将状态设为THINKING，查看相邻人的状态，若有等待则将其唤醒，否则直接释放资源，最后释放mutex退出管程。

 - 请在实验报告中给出给用户态进程/线程提供条件变量机制的设计方案，并比较说明给内核级提供条件变量机制的异同。
  - 与练习1的回答类似。
  - 用户态无法直接调用内核级函数，需要创建新的系统调用来实现。可以创建例如sys_init、sys_down、sys_up等系统调用，在中断处理历程中对应相应的内核级操作。
  - 与为内核级提供信号量机制相比
    - 相同之处：信号量结构本身也没有变化，初始化、P操作、V操作的具体实现都一样
    - 不同之处：不能直接在用户态实现信号量操作，必须通过中断等方式跳转到内核态统一接口进行操作和管理。

